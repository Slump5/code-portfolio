# Linked List Insertion Program

## Overview
This is a Motorola 68000 assembly language program designed to insert a new element into a linked list. The program runs on the EASy68K simulator and constructs a memory image of a linked list with elements e1, e2, e3, and e4. It then inserts a new element between e2 and e3, updating the necessary pointers to maintain the list structure. The program demonstrates pointer manipulation and linked data structures at the architecture level.

## Features
- **Linked List Construction:** Initializes a linked list with four elements (e1, e2, e3, e4) at specified memory addresses.
- **Element Insertion:** Inserts a new element between e2 and e3 by updating the next pointers.
- **Pointer-Based Operations:** Uses Motorola 68000 addressing modes to manage pointers and data.
- **EASy68K Compatibility:** Fully compatible with the EASy68K Editor/Assembler v5.16.01.
- **Memory Layout:** Adheres to the memory image specified in Figure 7.1 of the lab assignment.
- **Halt on Completion:** Uses `SIMHALT` to stop the simulator after insertion.

## File Structure
- **code.X68:** The main source file containing the Motorola 68000 assembly code for the linked list insertion program.
- **code.S68:** The S-record file generated by the assembler, containing the machine code for loading into the simulator.
- **code.L68:** The listing file showing the assembled code, memory addresses, opcodes, and symbol table.
- **untitled10.S68:** An alternate S-record file for a partial version of the program.
- **untitled10.L68:** An alternate listing file for a partial version of the program.
- **instructions.docx:** The lab assignment document outlining the requirements for the linked list insertion task.
- **linked-list-insertion-program-report-thomashoerger.pdf:** The lab report documenting the procedure, results, and memory displays before and after insertion.

## Requirements
- EASy68K Editor/Assembler v5.16.01 or compatible version
- Motorola 68000 simulator (included with EASy68K)
- A computer capable of running the EASy68K software

## Compilation and Running
1. Open the EASy68K Editor/Assembler.
2. Load the `code.X68` file into the editor.
3. Set up the simulator:
   - Load register `A5` with the address `$0074B0` before running the program (as specified in the lab instructions).
4. Assemble the program:
   - Click "Assemble" in the EASy68K interface to generate the machine code and verify no errors.
5. Run the program:
   - Use the simulator’s "Execute" function to run the program.
   - The program initializes the linked list and inserts the new element between e2 and e3.
6. Verify the result:
   - Inspect the memory window to confirm the linked list structure before and after insertion.
   - Check addresses `$0074A8` to `$0074D4` to verify the data and pointer updates.

## How It Works
1. **Linked List Initialization:**
   - **e1** at `$0074A8`: Stores data `41414141` and next pointer `$0074D0` (points to e2).
   - **e2** at `$0074D0`: Stores data `42424242` and next pointer `$0074B8` (points to e3).
   - **e3** at `$0074B8`: Stores data `43434343` and next pointer `$0074C0` (points to e4).
   - **e4** at `$0074C0`: Stores data `44444444` and next pointer `0` (end of list).
2. **New Element Insertion:**
   - The new element is initialized at `$0074B0` with data `45454545` and next pointer `$0074B8` (points to e3).
   - The next pointer of e2 (`$0074D4`) is updated to `$0074B0` (points to the new element).
3. **Pointer Setup (Lab Instructions):**
   - Before execution, `A5` is manually set to `$0074B0`.
   - The provided lab code (`LEA $0074A8,A6`, `MOVE.L 4(A6),A1`, `MOVE.L 4(A1),A2`) sets up pointers to e1, e2, and e3.
   - The insertion is completed with `MOVE.L A2,4(A5)` (new element’s next pointer to e3) and `MOVE.L A5,4(A1)` (e2’s next pointer to the new element).
4. **Termination:**
   - The program halts using `SIMHALT` after the insertion.

## Results
- **Before Execution:** The linked list is e1 → e2 → e3 → e4, with memory addresses and data as specified in Figure 7.1.
- **After Execution:** The new element is inserted, resulting in e1 → e2 → new element → e3 → e4.
- **Memory Verification:**
   - `$0074B0`: Data `45454545` (new element).
   - `$0074B4`: Next pointer `$0074B8` (points to e3).
   - `$0074D4`: Updated next pointer of e2 to `$0074B0` (points to new element).

## New Operations Used
- `MOVE.L`: Move Long
- `DC.L`: Define Constant Long
- `LEA`: Load Effective Address
- `LEA.L`: Load Effective Address Long
- `SIMHALT`: Halt the simulator

## Notes
- **Addressing Issue:** The program uses absolute addressing (e.g., `MOVE.L #e2,D0`), which may not be fully relocatable. For PC-relative addressing, instructions like `LEA e2(PC),A0` could be used.
- **Register A0 Issue:** The instruction `MOVE.L D1,4(A0)` assumes `A0` points to e2, but `A0` is not initialized in the code. The lab’s provided code uses `A1` for e2, so `MOVE.L D1,4(A1)` would be correct.
- **Manual Setup:** The lab requires manually setting `A5` to `$0074B0` before execution, which is not part of the program code.
- **Memory Layout:** The program adheres to the memory image in Figure 7.1, ensuring correct data and pointer placement.

## Future Improvements
- Implement PC-relative addressing to make the program fully relocatable.
- Fix the `A0` register issue by initializing it or using `A1` as per the lab’s pointer setup.
- Add a traversal routine to display the linked list before and after insertion.
- Include error checking for invalid memory addresses or pointer values.
- Support dynamic insertion points (e.g., insert at any position in the list).

## License
This project is for educational use as part of CSCI 320-54 Assignment 5. Retain the copyright notice: "Thomas Hoerger - Copyright © 2024 Linked List Insertion Program".