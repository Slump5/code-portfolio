# Vector Reversal Program

## Overview
This is a Motorola 68000 assembly language program designed to reverse the elements of an ASCII vector. The program runs on the EASy68K simulator and uses PC-relative addressing to ensure relocatability. The vector, containing the ASCII characters 'A' through 'J', is reversed by swapping elements from the start and end until the entire vector is inverted.

## Features
- **Vector Reversal:** Reverses a 10-character ASCII vector ('ABCDEFGHIJ') stored at memory location `$004AC4`.
- **PC-Relative Addressing:** Ensures the program is address-independent, allowing it to run anywhere in memory.
- **Efficient Algorithm:** Uses a two-pointer approach to swap elements from the start and end of the vector.
- **EASy68K Compatibility:** Fully compatible with the EASy68K Editor/Assembler v5.16.01.
- **Halt on Completion:** Uses `SIMHALT` to stop the simulator after reversing the vector.

## File Structure
- **code.X68:** The main source file containing the Motorola 68000 assembly code for the vector reversal program.
- **code.S68:** The S-record file generated by the assembler, containing the machine code for loading into the simulator.
- **code.L68:** The listing file showing the assembled code, memory addresses, opcodes, and symbol table.
- **instructions.docx:** The lab assignment document outlining the requirements for the vector reversal task.
- **vector-reversal-program-report-thomashoerger.pdf:** The lab report documenting the procedure, results, and figures showing the vector before and after reversal.

## Requirements
- EASy68K Editor/Assembler v5.16.01 or compatible version
- Motorola 68000 simulator (included with EASy68K)
- A computer capable of running the EASy68K software

## Compilation and Running
1. Open the EASy68K Editor/Assembler.
2. Load the `code.X68` file into the editor.
3. Assemble the program:
   - Click "Assemble" in the EASy68K interface to generate the machine code and verify no errors.
4. Run the program:
   - Use the simulator’s "Execute" function to run the program.
   - The vector at memory location `$004AC4` will be reversed.
5. Verify the result:
   - Inspect memory location `$004AC4` to confirm the vector is reversed (should be 'JIHGFEDCBA').

## How It Works
1. **Initialization:**
   - The vector 'ABCDEFGHIJ' is defined at `$004AC4` using `DC.B`.
   - The program starts at `$004AD0`, loading the vector’s address into register `A0` with `LEA VECTOR,A0`.
   - Register `D1` is set to 10 (vector length), `D2` to 0 (start index), and `D3` to 9 (end index).
2. **Reversal Loop:**
   - Loads bytes from the start (`(A0,D2)`) and end (`(A0,D3)`) of the vector into `D4` and `D5`.
   - Swaps the bytes by storing `D5` at the start and `D4` at the end.
   - Increments `D2` and decrements `D3` to move the pointers inward.
   - Continues until `D2` exceeds `D3` (checked with `CMP.L` and `BGE`).
3. **Termination:**
   - The program halts using `SIMHALT` after the vector is reversed.

## Results
- **Before Execution:** The vector at `$004AC4` contains 'ABCDEFGHIJ'.
- **After Execution:** The vector is reversed to 'JIHGFEDCBA'.
- **Verification:** The simulator’s memory display confirms the reversed vector.

## New Operations Used
- `LEA`: Load Effective Address
- `MOVEQ`: Move Quick (for immediate values)
- `MOVE.L`: Move Long
- `DC.B`: Define Constant Byte
- `MOVE.B`: Move Byte
- `ADDQ.L`: Add Quick Long
- `SUBQ.L`: Subtract Quick Long
- `CMP.L`: Compare Long
- `BGE`: Branch if Greater or Equal
- `SIMHALT`: Halt the simulator

## Notes
- **PC-Relative Addressing:** The program uses `LEA VECTOR,A0` for addressing, but the lab requires PC-relative addressing. The provided code uses absolute addressing, which may not fully meet the relocatability requirement. To make it fully PC-relative, `LEA VECTOR(PC),A0` could be used instead.
- **Vector Length:** The vector has 10 characters, but the code correctly handles the 0-based indexing (9 as the last index).
- **Error Handling:** The program assumes the vector length is 10 and does not include error checking for invalid memory or vector sizes.

## Future Improvements
- Implement full PC-relative addressing using `LEA VECTOR(PC),A0` to meet the lab’s relocatability requirement.
- Add error checking for vector length or memory bounds.
- Include a display routine to output the vector before and after reversal directly in the simulator.
- Extend the program to handle variable-length vectors by passing the length as a parameter.

## License
This project is for educational and personal. Retain the copyright notice: "Thomas Hoerger - Copyright © 2024 Vector Reversal Program".