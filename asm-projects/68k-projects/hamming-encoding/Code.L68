00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 4/6/2024 3:36:27 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Hamming Encoding
00000000                             3  * Written by : Thomas Hoerger
00000000                             4  * Date       : 4/6/2024
00000000                             5  * Description: Converts a given message into an encoded message. Thomas Hoerger - Copyright Â© 2024 Hamming Encoding.
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000        ; Start of program at memory address $1000
00001000                             8  START:
00001000  7400                       9      MOVE.L #0,D2         ; Initialize register D2 to 0
00001002  7600                      10      MOVE.L #0,D3         ; Initialize register D3 to 0
00001004  7800                      11      MOVE.L #0,D4         ; Initialize register D4 to 0
00001006  7A00                      12      MOVE.L #0,D5         ; Initialize register D5 to 0
00001008  7C00                      13      MOVE.L #0,D6         ; Initialize register D6 to 0
0000100A  7E00                      14      MOVE.L #0,D7         ; Initialize register D7 to 0
0000100C                            15      
0000100C                            16  
0000100C  11FC 000B 2400            17      MOVE.B #11,$00002400 ; Load byte from memory address $00002400 into D1
00001012  41F8 2400                 18      LEA.L $00002400,A0   ; Load effective address of $00002400 into A0
00001016  1210                      19      MOVE.B (A0),D1       ; Move byte from memory into D1
00001018                            20      
00001018                            21  
00001018  7401                      22      MOVE.L #1,D2         ; Load 1 into D2
0000101A  7602                      23      MOVE.L #2,D3         ; Load 2 into D3
0000101C  7804                      24      MOVE.L #4,D4         ; Load 4 into D4
0000101E  7A08                      25      MOVE.L #8,D5         ; Load 8 into D5
00001020                            26  
00001020  C441                      27      AND.W D1,D2           ; Bitwise AND between D1 and D2, storing result in D2 (D2 = D)
00001022  C641                      28      AND.W D1,D3           ; Bitwise AND between D1 and D3, storing result in D3 (D3 = C)
00001024  C841                      29      AND.W D1,D4           ; Bitwise AND between D1 and D4, storing result in D4 (D4 = B)
00001026  CA41                      30      AND.W D1,D5           ; Bitwise AND between D1 and D5, storing result in D5 (D5 = A)
00001028                            31  
00001028  E24B                      32      LSR.W #1,D3           ; Logical shift right by 1 bit in D3 (right shift b bit)
0000102A  E44C                      33      LSR.W #2,D4           ; Logical shift right by 2 bits in D4 (right shift c bit)
0000102C  E64D                      34      LSR.W #3,D5           ; Logical shift right by 3 bits in D5 (right shift d bit)
0000102E                            35  
0000102E  1005                      36      MOVE.B D5,D0          ; Move D5 (A bit) into D0
00001030                            37  
00001030  B945                      38      EOR.W D4,D5           ; Bitwise exclusive OR between D4 and D5, storing result in D5 (D5 = R)
00001032  B745                      39      EOR.W D3,D5           ; Bitwise exclusive OR between D3 and D5, storing result in D5 (D5 = R)
00001034                            40  
00001034  E249                      41      LSR.W #1,D1           ; Logical shift right by 1 bit in D1 (right shift a bit)
00001036  E349                      42      LSL.W #1,D1           ; Logical shift left by 1 bit in D1 (left shift a bit)
00001038                            43  
00001038  BB41                      44      EOR.W D5,D1           ; Bitwise exclusive OR between D5 and D1, storing result in D1 (D1 = ABCR)
0000103A  E349                      45      LSL.W #1,D1           ; Logical shift left by 1 bit in D1 (left shift ABCR to ABCR0)
0000103C                            46  
0000103C  B541                      47      EOR.W D2,D1           ; Bitwise exclusive OR between D2 and D1, storing result in D1 (D1 = ABCRD)
0000103E  E349                      48      LSL.W #1,D1           ; Logical shift left by 1 bit in D1 (left shift ABCRD to ABCRD0)
00001040                            49  
00001040  B144                      50      EOR.W D0,D4           ; Bitwise exclusive OR between D0 and D4, storing result in D4 (D4 = S)
00001042                            51  
00001042  B143                      52      EOR.W D0,D3           ; Bitwise exclusive OR between D0 and D3, storing result in D3 (D3 = T)
00001044                            53  
00001044  B941                      54      EOR.W D4,D1           ; Bitwise exclusive OR between D4 and D1, storing result in D1 (D1 = ABCRDS)
00001046  E349                      55      LSL.W #1,D1           ; Logical shift left by 1 bit in D1 (left shift ABCRDS to ABCRDS0)
00001048                            56  
00001048  B741                      57      EOR.W D3,D1           ; Bitwise exclusive OR between D3 and D1, storing result in D1 (D1 = ABCRDST)
0000104A                            58  
0000104A                            59  * Put program code here
0000104A                            60  
0000104A  FFFF FFFF                 61      SIMHALT             ; halt simulator
0000104E                            62  
0000104E                            63  * Put variables and constants here
0000104E                            64  
0000104E                            65      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
START               1000
